{"version":3,"file":"gitignoreParser.umd.js","sources":["../lib/index.js"],"sourcesContent":["\n// force to false and smart code compressors can remove the resulting 'dead code':\nconst DEBUG = false;\n\n/**\n * Compile the given `.gitignore` content (not filename!)\n * and return an object with `accepts`, `denies` and `inspects` methods.\n * These methods each accepts a single filename or path and determines whether\n * they are acceptable or unacceptable according to the `.gitignore` definition.\n *\n * @param  {String} content The `.gitignore` content to compile.\n * @return {Object}         The helper object with methods that operate on the compiled content.\n */\nexport function compile(content) {\n  let parsed = parse(content),\n      positives = parsed[0],\n      negatives = parsed[1];\n\n  return {\n    /// Helper (which can be overridden by userland code) invoked when\n    /// any `accepts()`, `denies()` or `inspects()` fail to help\n    /// the developer analyze what is going on inside: some gitignore spec\n    /// bits are non-intuitive / non-trivial, after all.\n    diagnose: function (query) {\n      if (DEBUG) {\n        console.log(`${query.query}:`, query);\n      }\n    },\n    /// Return TRUE when the given `input` path PASSES the gitignore filters,\n    /// i.e. when the given input path is DENIED.\n    ///\n    /// Notes:\n    /// - you MUST postfix a input directory with '/' to ensure the gitignore\n    ///   rules can be applied conform spec.\n    /// - you MAY prefix a input directory with '/' when that directory is\n    ///   'rooted' in the same directory as the compiled .gitignore spec file.\n    accepts: function (input, expected) {\n      if (input[0] === '/') input = input.slice(1);\n      input = '/' + input;\n\n      let acceptRe = negatives;\n      let acceptTest = acceptRe.test(input);\n      let denyRe = positives;\n      let denyTest = denyRe.test(input);\n      let returnVal = (acceptTest || !denyTest);\n\n      if (expected != null && expected !== returnVal) {\n        this.diagnose({ query: 'accepts', input, expected, acceptRe, acceptTest, denyRe, denyTest, combine: '(Accept || !Deny)', returnVal });\n      }\n      return returnVal;\n    },\n    /// Return TRUE when the given `input` path FAILS the gitignore filters,\n    /// i.e. when the given input path is ACCEPTED.\n    ///\n    /// Notes:\n    /// - you MUST postfix a input directory with '/' to ensure the gitignore\n    ///   rules can be applied conform spec.\n    /// - you MAY prefix a input directory with '/' when that directory is\n    ///   'rooted' in the same directory as the compiled .gitignore spec file.\n    denies: function (input, expected) {\n      if (input[0] === '/') input = input.slice(1);\n      input = '/' + input;\n\n      let acceptRe = negatives;\n      let acceptTest = acceptRe.test(input);\n      let denyRe = positives;\n      let denyTest = denyRe.test(input);\n      // boolean logic:\n      //\n      // denies = !accepts =>\n      // = !(Accept || !Deny) =>\n      // = (!Accept && !!Deny) =>\n      // = (!Accept && Deny)\n      let returnVal = (!acceptTest && denyTest);\n\n      if (expected != null && expected !== returnVal) {\n        this.diagnose({ query: 'denies', input, expected, acceptRe, acceptTest, denyRe, denyTest, combine: '(!Accept && Deny)', returnVal });\n      }\n      return returnVal;\n    },\n    /// Return TRUE when the given `input` path is inspected by any .gitignore\n    /// filter line.\n    ///\n    /// You can use this method to help construct the decision path when you\n    /// process nested .gitignore files: .gitignore filters in subdirectories\n    /// MAY override parent .gitignore filters only when there's actually ANY\n    /// filter in the child .gitignore after all.\n    ///\n    /// Notes:\n    /// - you MUST postfix a input directory with '/' to ensure the gitignore\n    ///   rules can be applied conform spec.\n    /// - you MAY prefix a input directory with '/' when that directory is\n    ///   'rooted' in the same directory as the compiled .gitignore spec file.\n    inspects: function (input, expected) {\n      if (input[0] === '/') input = input.slice(1);\n      input = '/' + input;\n\n      let acceptRe = negatives;\n      let acceptTest = acceptRe.test(input);\n      let denyRe = positives;\n      let denyTest = denyRe.test(input);\n      // when any filter 'touches' the input path, it must match,\n      // no matter whether it's a deny or accept filter line:\n      let returnVal = (acceptTest || denyTest);\n\n      if (expected != null && expected !== returnVal) {\n        this.diagnose({ query: 'inspects', input, expected, acceptRe, acceptTest, denyRe, denyTest, combine: '(Accept || Deny)', returnVal });\n      }\n      return returnVal;\n    }\n  };\n}\n\n/**\n * Parse the given `.gitignore` content and return an array\n * containing positives and negatives.\n * Each of these in turn contains a regexp which will be\n * applied to the 'rooted' paths to test for *deny* or *accept*\n * respectively.\n *\n * @param  {String} content  The content to parse,\n * @return {Array[]}         The parsed positive and negatives definitions.\n */\nexport function parse(content) {\n  return content.split('\\n')\n  .map(function (line) {\n    line = line.trim();\n    return line;\n  })\n  .filter(function (line) {\n    return line && line[0] !== '#';\n  })\n  .reduce(function (lists, line) {\n    let isNegative = line[0] === '!';\n    if (isNegative) {\n      line = line.slice(1);\n    }\n    if (isNegative) {\n      lists[1].push(line);\n    } else {\n      lists[0].push(line);\n    }\n    return lists;\n  }, [ [], [] ])\n  .map(function (list) {\n    list =  list\n    .sort()\n    .map(prepareRegexPattern);\n\n    // don't need submatches, hence we use should use non-capturing `(?:...)` grouping regexes:\n    // those are generally faster than their submatch-capturing brothers:\n    if (list.length > 0) {\n      return new RegExp('(?:' + list.join(')|(?:') + ')');\n    }\n    // this regex *won't match a thing*:\n    return new RegExp('$^');\n\n  });\n}\n\nfunction prepareRegexPattern(pattern) {\n  // https://git-scm.com/docs/gitignore#_pattern_format\n  //\n  // * ...\n  //\n  // * If there is a separator at the beginning or middle (or both) of the pattern,\n  //   then the pattern is relative to the directory level of the particular\n  //   .gitignore file itself.\n  //   Otherwise the pattern may also match at any level below the .gitignore level.\n  //\n  // * ...\n  //\n  // * For example, a pattern `doc/frotz/` matches `doc/frotz` directory, but\n  //   not `a/doc/frotz` directory; however `frotz/` matches `frotz` and `a/frotz`\n  //   that is a directory (all paths are relative from the .gitignore file).\n  //\n  let input = pattern;\n  let re = '';\n  let rooted = false;\n  let directory = false;\n  if (pattern[0] === '/') {\n    rooted = true;\n    pattern = pattern.slice(1);\n  }\n  if (pattern[pattern.length - 1] === '/') {\n    directory = true;\n    pattern = pattern.slice(0, pattern.length - 1);\n  }\n  // keep character ranges intact:\n  const rangeRe = /^((?:[^\\[\\\\]|(?:\\\\.))*)\\[((?:[^\\]\\\\]|(?:\\\\.))*)\\]/;\n  // ^ could have used the 'y' sticky flag, but there's some trouble with infine loops inside\n  //   the matcher below then...\n  let match;\n\n  while ((match = rangeRe.exec(pattern)) !== null) {\n    if (match[1].includes('/')) {\n      rooted = true;\n      // ^ cf. man page:\n      //\n      //   If there is a separator at the beginning or middle (or both)\n      //   of the pattern, then the pattern is relative to the directory\n      //   level of the particular .gitignore file itself. Otherwise\n      //   the pattern may also match at any level below the .gitignore level.\n    }\n    re += transpileRegexPart(match[1]);\n    re += '[' + match[2] + ']';\n\n    pattern = pattern.slice(match[0].length);\n  }\n  if (pattern) {\n    if (pattern.includes('/')) {\n      rooted = true;\n      // ^ cf. man page:\n      //\n      //   If there is a separator at the beginning or middle (or both)\n      //   of the pattern, then the pattern is relative to the directory\n      //   level of the particular .gitignore file itself. Otherwise\n      //   the pattern may also match at any level below the .gitignore level.\n    }\n    re += transpileRegexPart(pattern);\n  }\n\n  // prep regexes assuming we'll always prefix the check string with a '/':\n  if (rooted) {\n    re = '^\\\\/' + re;\n  } else {\n    re = '\\\\/' + re;\n  }\n  // cf spec:\n  //\n  //   If there is a separator at the end of the pattern then the pattern\n  //   will only match directories, otherwise the pattern can match\n  //   **both files and directories**.                   (emphasis mine)\n  if (directory) {\n    re += '\\\\/$';\n  } else {\n    re += '\\\\/?$';\n  }\n\n  // regex validation diagnostics: better to check if the part is valid\n  // then to discover it's gone haywire in the big conglomerate at the end.\n  if (DEBUG) {\n    try {\n    /* eslint no-new:1 */\n      new RegExp('(?:' + re + ')');\n    } catch (ex) {\n      console.log('failed regex:', { input, re, ex });\n    }\n  }\n  return re;\n}\n\nfunction transpileRegexPart(re) {\n  return re\n      // unescape for these will be escaped again in the subsequent `.replace(...)`,\n      // whether they were escaped before or not:\n      .replace(/\\\\(.)/g, '$1')\n      // escape special regex characters:\n      .replace(/[\\-\\[\\]\\{\\}\\(\\)\\+\\.\\\\\\^\\$\\|]/g, '\\\\$&')\n      .replace(/\\?/g, '[^/]')\n      .replace(/\\/\\*\\*\\//g, '(?:/|(?:/.+/))')\n      .replace(/^\\*\\*\\//g, '(?:|(?:.+/))')\n      .replace(/\\/\\*\\*$/g, '(?:|(?:/.+))')    // `a/**` also accepts `a/` itself\n      .replace(/\\*\\*/g, '.*')\n      .replace(/\\*/g, '[^/]*')\n      .replace(/\\//g, '\\\\/');\n}\n"],"names":["compile","content","parsed","parse","positives","negatives","diagnose","query","accepts","input","expected","slice","acceptRe","acceptTest","test","denyRe","denyTest","returnVal","combine","denies","inspects","split","map","line","trim","filter","reduce","lists","isNegative","push","list","sort","prepareRegexPattern","length","RegExp","join","pattern","re","rooted","directory","rangeRe","match","exec","includes","transpileRegexPart","replace"],"mappings":"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"}