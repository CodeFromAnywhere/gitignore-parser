{"version":3,"file":"gitignoreParser.umd.js","sources":["../lib/index.js"],"sourcesContent":["\n// force to false and smart code compressors can remove the resulting 'dead code':\nconst DEBUG = true;\n\n/**\n * Compile the given `.gitignore` content (not filename!)\n * and return an object with `accepts`, `denies` and `inspects` methods.\n * These methods each accepts a single filename or path and determines whether\n * they are acceptable or unacceptable according to the `.gitignore` definition.\n *\n * @param  {String} content The `.gitignore` content to compile.\n * @return {Object}         The helper object with methods that operate on the compiled content.\n */\nexport function compile(content) {\n  let parsed = parse(content),\n      positives = parsed[0],\n      negatives = parsed[1];\n\n  return {\n    /// Helper (which can be overridden by userland code) invoked when\n    /// any `accepts()`, `denies()` or `inspects()` fail to help\n    /// the developer analyze what is going on inside: some gitignore spec\n    /// bits are non-intuitive / non-trivial, after all.\n    diagnose: function (query) {\n      if (DEBUG) {\n        console.log(`${query.query}:`, query);\n      }\n    },\n    /// Return TRUE when the given `input` path PASSES the gitignore filters,\n    /// i.e. when the given input path is DENIED.\n    ///\n    /// Notes:\n    /// - you MUST postfix a input directory with '/' to ensure the gitignore\n    ///   rules can be applied conform spec.\n    /// - you MAY prefix a input directory with '/' when that directory is\n    ///   'rooted' in the same directory as the compiled .gitignore spec file.\n    accepts: function (input, expected) {\n      if (input[0] === '/') input = input.slice(1);\n      input = '/' + input;\n\n      let acceptRe = negatives[0];\n      let acceptTest = acceptRe.test(input);\n      let denyRe = positives[0];\n      let denyTest = denyRe.test(input);\n      let returnVal = (acceptTest || !denyTest);\n      // See the test/fixtures/gitignore.manpage.txt near line 680 (grep for \"uber-nasty\"):\n      // to resolve chained rules which reject, then accept, we need to establish\n      // the precedence of both accept and reject parts of the compiled gitignore by\n      // comparing match lengths.\n      // Since the generated consolidated regexes are lazy, we must loop through all lines' regexes instead:\n      let acceptMatch, denyMatch;\n      if (acceptTest && denyTest) {\n        for (let re of negatives[1]) {\n          let m = re.exec(input);\n          if (m) {\n            if (!acceptMatch) {\n              acceptMatch = m;\n            } else if (acceptMatch[0].length < m[0].length) {\n              acceptMatch = m;\n            }\n          }\n        }\n        for (let re of positives[1]) {\n          let m = re.exec(input);\n          if (m) {\n            if (!denyMatch) {\n              denyMatch = m;\n            } else if (denyMatch[0].length < m[0].length) {\n              denyMatch = m;\n            }\n          }\n        }\n        // acceptMatch = acceptRe.exec(input);\n        // denyMatch = denyRe.exec(input);\n\n        returnVal = (acceptMatch[0].length >= denyMatch[0].length);\n      }\n\n      if (expected != null && expected !== returnVal) {\n        this.diagnose({ query: 'accepts', input, expected, acceptRe, acceptTest, acceptMatch, denyRe, denyTest, denyMatch, combine: '(Accept || !Deny)', returnVal });\n      }\n      return returnVal;\n    },\n    /// Return TRUE when the given `input` path FAILS the gitignore filters,\n    /// i.e. when the given input path is ACCEPTED.\n    ///\n    /// Notes:\n    /// - you MUST postfix a input directory with '/' to ensure the gitignore\n    ///   rules can be applied conform spec.\n    /// - you MAY prefix a input directory with '/' when that directory is\n    ///   'rooted' in the same directory as the compiled .gitignore spec file.\n    denies: function (input, expected) {\n      if (input[0] === '/') input = input.slice(1);\n      input = '/' + input;\n\n      let acceptRe = negatives[0];\n      let acceptTest = acceptRe.test(input);\n      let denyRe = positives[0];\n      let denyTest = denyRe.test(input);\n      // boolean logic:\n      //\n      // denies = !accepts =>\n      // = !(Accept || !Deny) =>\n      // = (!Accept && !!Deny) =>\n      // = (!Accept && Deny)\n      let returnVal = (!acceptTest && denyTest);\n      // See the test/fixtures/gitignore.manpage.txt near line 680 (grep for \"uber-nasty\"):\n      // to resolve chained rules which reject, then accept, we need to establish\n      // the precedence of both accept and reject parts of the compiled gitignore by\n      // comparing match lengths.\n      // Since the generated regexes are all set up to be GREEDY, we can use the\n      // consolidated regex for this, instead of having to loop through all lines' regexes:\n      let acceptMatch, denyMatch;\n      if (acceptTest && denyTest) {\n        for (let re of negatives[1]) {\n          let m = re.exec(input);\n          if (m) {\n            if (!acceptMatch) {\n              acceptMatch = m;\n            } else if (acceptMatch[0].length < m[0].length) {\n              acceptMatch = m;\n            }\n          }\n        }\n        for (let re of positives[1]) {\n          let m = re.exec(input);\n          if (m) {\n            if (!denyMatch) {\n              denyMatch = m;\n            } else if (denyMatch[0].length < m[0].length) {\n              denyMatch = m;\n            }\n          }\n        }\n        // acceptMatch = acceptRe.exec(input);\n        // denyMatch = denyRe.exec(input);\n\n        // boolean logic: !(A>=B) ==> A<B\n        returnVal = (acceptMatch[0].length < denyMatch[0].length);\n      }\n\n      if (expected != null && expected !== returnVal) {\n        this.diagnose({ query: 'denies', input, expected, acceptRe, acceptTest, acceptMatch, denyRe, denyTest, denyMatch, combine: '(!Accept && Deny)', returnVal });\n      }\n      return returnVal;\n    },\n    /// Return TRUE when the given `input` path is inspected by any .gitignore\n    /// filter line.\n    ///\n    /// You can use this method to help construct the decision path when you\n    /// process nested .gitignore files: .gitignore filters in subdirectories\n    /// MAY override parent .gitignore filters only when there's actually ANY\n    /// filter in the child .gitignore after all.\n    ///\n    /// Notes:\n    /// - you MUST postfix a input directory with '/' to ensure the gitignore\n    ///   rules can be applied conform spec.\n    /// - you MAY prefix a input directory with '/' when that directory is\n    ///   'rooted' in the same directory as the compiled .gitignore spec file.\n    inspects: function (input, expected) {\n      if (input[0] === '/') input = input.slice(1);\n      input = '/' + input;\n\n      let acceptRe = negatives[0];\n      let acceptTest = acceptRe.test(input);\n      let denyRe = positives[0];\n      let denyTest = denyRe.test(input);\n      // when any filter 'touches' the input path, it must match,\n      // no matter whether it's a deny or accept filter line:\n      let returnVal = (acceptTest || denyTest);\n\n      if (expected != null && expected !== returnVal) {\n        this.diagnose({ query: 'inspects', input, expected, acceptRe, acceptTest, denyRe, denyTest, combine: '(Accept || Deny)', returnVal });\n      }\n      return returnVal;\n    }\n  };\n}\n\n/**\n * Parse the given `.gitignore` content and return an array\n * containing positives and negatives.\n * Each of these in turn contains a regexp which will be\n * applied to the 'rooted' paths to test for *deny* or *accept*\n * respectively.\n *\n * @param  {String} content  The content to parse,\n * @return {Array[]}         The parsed positive and negatives definitions.\n */\nexport function parse(content) {\n  return content.split('\\n')\n  .map(function (line) {\n    line = line.trim();\n    return line;\n  })\n  .filter(function (line) {\n    return line && line[0] !== '#';\n  })\n  .reduce(function (lists, line) {\n    let isNegative = line[0] === '!';\n    if (isNegative) {\n      line = line.slice(1);\n    }\n    if (isNegative) {\n      lists[1].push(line);\n    } else {\n      lists[0].push(line);\n    }\n    return lists;\n  }, [ [], [] ])\n  .map(function (list) {\n    list =  list\n    .sort()\n    .map(prepareRegexPattern);\n\n    // don't need submatches, hence we use should use non-capturing `(?:...)` grouping regexes:\n    // those are generally faster than their submatch-capturing brothers:\n    if (list.length > 0) {\n      return [ new RegExp('(?:' + list.join(')|(?:') + ')'), list.map((re) => new RegExp(re)) ];\n    }\n    // this regex *won't match a thing*:\n    return [ new RegExp('$^'), [] ];\n  });\n}\n\nfunction prepareRegexPattern(pattern) {\n  // https://git-scm.com/docs/gitignore#_pattern_format\n  //\n  // * ...\n  //\n  // * If there is a separator at the beginning or middle (or both) of the pattern,\n  //   then the pattern is relative to the directory level of the particular\n  //   .gitignore file itself.\n  //   Otherwise the pattern may also match at any level below the .gitignore level.\n  //\n  // * ...\n  //\n  // * For example, a pattern `doc/frotz/` matches `doc/frotz` directory, but\n  //   not `a/doc/frotz` directory; however `frotz/` matches `frotz` and `a/frotz`\n  //   that is a directory (all paths are relative from the .gitignore file).\n  //\n  let input = pattern;\n  let re = '';\n  let rooted = false;\n  let directory = false;\n  if (pattern[0] === '/') {\n    rooted = true;\n    pattern = pattern.slice(1);\n  }\n  if (pattern[pattern.length - 1] === '/') {\n    directory = true;\n    pattern = pattern.slice(0, pattern.length - 1);\n  }\n  // keep character ranges intact:\n  const rangeRe = /^((?:[^\\[\\\\]|(?:\\\\.))*)\\[((?:[^\\]\\\\]|(?:\\\\.))*)\\]/;\n  // ^ could have used the 'y' sticky flag, but there's some trouble with infine loops inside\n  //   the matcher below then...\n  let match;\n\n  while ((match = rangeRe.exec(pattern)) !== null) {\n    if (match[1].includes('/')) {\n      rooted = true;\n      // ^ cf. man page:\n      //\n      //   If there is a separator at the beginning or middle (or both)\n      //   of the pattern, then the pattern is relative to the directory\n      //   level of the particular .gitignore file itself. Otherwise\n      //   the pattern may also match at any level below the .gitignore level.\n    }\n    re += transpileRegexPart(match[1]);\n    re += '[' + match[2] + ']';\n\n    pattern = pattern.slice(match[0].length);\n  }\n  if (pattern) {\n    if (pattern.includes('/')) {\n      rooted = true;\n      // ^ cf. man page:\n      //\n      //   If there is a separator at the beginning or middle (or both)\n      //   of the pattern, then the pattern is relative to the directory\n      //   level of the particular .gitignore file itself. Otherwise\n      //   the pattern may also match at any level below the .gitignore level.\n    }\n    re += transpileRegexPart(pattern);\n  }\n\n  // prep regexes assuming we'll always prefix the check string with a '/':\n  if (rooted) {\n    re = '^\\\\/' + re;\n  } else {\n    re = '\\\\/' + re;\n  }\n  // cf spec:\n  //\n  //   If there is a separator at the end of the pattern then the pattern\n  //   will only match directories, otherwise the pattern can match\n  //   **both files and directories**.                   (emphasis mine)\n  if (directory) {\n    // match the directory itself and anything within:\n    re += '\\\\/';\n  } else {\n    // match the file itself, or, when it is a directory, match the directory and anything within:\n    re += '(?:$|\\\\/)';\n  }\n\n  // regex validation diagnostics: better to check if the part is valid\n  // then to discover it's gone haywire in the big conglomerate at the end.\n  if (DEBUG) {\n    try {\n    /* eslint no-new:1 */\n      new RegExp('(?:' + re + ')');\n    } catch (ex) {\n      console.log('failed regex:', { input, re, ex });\n    }\n  }\n  return re;\n\n  function transpileRegexPart(re) {\n    return re\n      // unescape for these will be escaped again in the subsequent `.replace(...)`,\n      // whether they were escaped before or not:\n      .replace(/\\\\(.)/g, '$1')\n      // escape special regex characters:\n      .replace(/[\\-\\[\\]\\{\\}\\(\\)\\+\\.\\\\\\^\\$\\|]/g, '\\\\$&')\n      .replace(/\\?/g, '[^/]')\n      .replace(/\\/\\*\\*\\//g, '(?:/|(?:/.+/))')\n      .replace(/^\\*\\*\\//g, '(?:|(?:.+/))')\n      .replace(/\\/\\*\\*$/g, () => {\n        directory = true;        // `a/**` should match `a/`, `a/b/` and `a/b`, the latter by implication of matching directory `a/`\n        return '(?:|(?:/.+))';    // `a/**` also accepts `a/` itself\n      })\n      .replace(/\\*\\*/g, '.*')\n      // `a/*` should match `a/b` and `a/b/` but NOT `a` or `a/`\n      // meanwhile, `a/*/` should match `a/b/` and `a/b/c` but NOT `a` or `a/` or `a/b`\n      .replace(/\\/\\*(\\/|$)/g, '/[^/]+$1')\n      .replace(/\\*/g, '[^/]*')\n      .replace(/\\//g, '\\\\/');\n  }\n}\n"],"names":["compile","content","parsed","parse","positives","negatives","diagnose","query","console","log","accepts","input","expected","slice","acceptRe","acceptTest","test","denyRe","denyTest","returnVal","acceptMatch","denyMatch","re","m","exec","length","combine","denies","inspects","split","map","line","trim","filter","reduce","lists","isNegative","push","list","sort","prepareRegexPattern","RegExp","join","pattern","rooted","directory","rangeRe","match","includes","transpileRegexPart","ex","replace"],"mappings":";;;;;;EACA;EAGA;;;;;;;;;;EASO,SAASA,OAAT,CAAiBC,OAAjB,EAA0B;EAC/B,MAAIC,MAAM,GAAGC,KAAK,CAACF,OAAD,CAAlB;EAAA,MACIG,SAAS,GAAGF,MAAM,CAAC,CAAD,CADtB;EAAA,MAEIG,SAAS,GAAGH,MAAM,CAAC,CAAD,CAFtB;EAIA,SAAO;EACL;EACA;EACA;EACA;EACAI,IAAAA,QAAQ,EAAE,UAAUC,KAAV,EAAiB;EACzB,MAAW;EACTC,QAAAA,OAAO,CAACC,GAAR,CAAa,GAAEF,KAAK,CAACA,KAAM,GAA3B,EAA+BA,KAA/B;EACD;EACF,KATI;EAUL;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAG,IAAAA,OAAO,EAAE,UAAUC,KAAV,EAAiBC,QAAjB,EAA2B;EAClC,UAAID,KAAK,CAAC,CAAD,CAAL,KAAa,GAAjB,EAAsBA,KAAK,GAAGA,KAAK,CAACE,KAAN,CAAY,CAAZ,CAAR;EACtBF,MAAAA,KAAK,GAAG,MAAMA,KAAd;EAEA,UAAIG,QAAQ,GAAGT,SAAS,CAAC,CAAD,CAAxB;EACA,UAAIU,UAAU,GAAGD,QAAQ,CAACE,IAAT,CAAcL,KAAd,CAAjB;EACA,UAAIM,MAAM,GAAGb,SAAS,CAAC,CAAD,CAAtB;EACA,UAAIc,QAAQ,GAAGD,MAAM,CAACD,IAAP,CAAYL,KAAZ,CAAf;EACA,UAAIQ,SAAS,GAAIJ,UAAU,IAAI,CAACG,QAAhC,CARkC;EAUlC;EACA;EACA;EACA;;EACA,UAAIE,WAAJ,EAAiBC,SAAjB;;EACA,UAAIN,UAAU,IAAIG,QAAlB,EAA4B;EAC1B,aAAK,IAAII,EAAT,IAAejB,SAAS,CAAC,CAAD,CAAxB,EAA6B;EAC3B,cAAIkB,CAAC,GAAGD,EAAE,CAACE,IAAH,CAAQb,KAAR,CAAR;;EACA,cAAIY,CAAJ,EAAO;EACL,gBAAI,CAACH,WAAL,EAAkB;EAChBA,cAAAA,WAAW,GAAGG,CAAd;EACD,aAFD,MAEO,IAAIH,WAAW,CAAC,CAAD,CAAX,CAAeK,MAAf,GAAwBF,CAAC,CAAC,CAAD,CAAD,CAAKE,MAAjC,EAAyC;EAC9CL,cAAAA,WAAW,GAAGG,CAAd;EACD;EACF;EACF;;EACD,aAAK,IAAID,EAAT,IAAelB,SAAS,CAAC,CAAD,CAAxB,EAA6B;EAC3B,cAAImB,CAAC,GAAGD,EAAE,CAACE,IAAH,CAAQb,KAAR,CAAR;;EACA,cAAIY,CAAJ,EAAO;EACL,gBAAI,CAACF,SAAL,EAAgB;EACdA,cAAAA,SAAS,GAAGE,CAAZ;EACD,aAFD,MAEO,IAAIF,SAAS,CAAC,CAAD,CAAT,CAAaI,MAAb,GAAsBF,CAAC,CAAC,CAAD,CAAD,CAAKE,MAA/B,EAAuC;EAC5CJ,cAAAA,SAAS,GAAGE,CAAZ;EACD;EACF;EACF,SApByB;EAsB1B;;;EAEAJ,QAAAA,SAAS,GAAIC,WAAW,CAAC,CAAD,CAAX,CAAeK,MAAf,IAAyBJ,SAAS,CAAC,CAAD,CAAT,CAAaI,MAAnD;EACD;;EAED,UAAIb,QAAQ,IAAI,IAAZ,IAAoBA,QAAQ,KAAKO,SAArC,EAAgD;EAC9C,aAAKb,QAAL,CAAc;EAAEC,UAAAA,KAAK,EAAE,SAAT;EAAoBI,UAAAA,KAApB;EAA2BC,UAAAA,QAA3B;EAAqCE,UAAAA,QAArC;EAA+CC,UAAAA,UAA/C;EAA2DK,UAAAA,WAA3D;EAAwEH,UAAAA,MAAxE;EAAgFC,UAAAA,QAAhF;EAA0FG,UAAAA,SAA1F;EAAqGK,UAAAA,OAAO,EAAE,mBAA9G;EAAmIP,UAAAA;EAAnI,SAAd;EACD;;EACD,aAAOA,SAAP;EACD,KAhEI;EAiEL;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAQ,IAAAA,MAAM,EAAE,UAAUhB,KAAV,EAAiBC,QAAjB,EAA2B;EACjC,UAAID,KAAK,CAAC,CAAD,CAAL,KAAa,GAAjB,EAAsBA,KAAK,GAAGA,KAAK,CAACE,KAAN,CAAY,CAAZ,CAAR;EACtBF,MAAAA,KAAK,GAAG,MAAMA,KAAd;EAEA,UAAIG,QAAQ,GAAGT,SAAS,CAAC,CAAD,CAAxB;EACA,UAAIU,UAAU,GAAGD,QAAQ,CAACE,IAAT,CAAcL,KAAd,CAAjB;EACA,UAAIM,MAAM,GAAGb,SAAS,CAAC,CAAD,CAAtB;EACA,UAAIc,QAAQ,GAAGD,MAAM,CAACD,IAAP,CAAYL,KAAZ,CAAf,CAPiC;EASjC;EACA;EACA;EACA;EACA;;EACA,UAAIQ,SAAS,GAAI,CAACJ,UAAD,IAAeG,QAAhC,CAdiC;EAgBjC;EACA;EACA;EACA;EACA;;EACA,UAAIE,WAAJ,EAAiBC,SAAjB;;EACA,UAAIN,UAAU,IAAIG,QAAlB,EAA4B;EAC1B,aAAK,IAAII,EAAT,IAAejB,SAAS,CAAC,CAAD,CAAxB,EAA6B;EAC3B,cAAIkB,CAAC,GAAGD,EAAE,CAACE,IAAH,CAAQb,KAAR,CAAR;;EACA,cAAIY,CAAJ,EAAO;EACL,gBAAI,CAACH,WAAL,EAAkB;EAChBA,cAAAA,WAAW,GAAGG,CAAd;EACD,aAFD,MAEO,IAAIH,WAAW,CAAC,CAAD,CAAX,CAAeK,MAAf,GAAwBF,CAAC,CAAC,CAAD,CAAD,CAAKE,MAAjC,EAAyC;EAC9CL,cAAAA,WAAW,GAAGG,CAAd;EACD;EACF;EACF;;EACD,aAAK,IAAID,EAAT,IAAelB,SAAS,CAAC,CAAD,CAAxB,EAA6B;EAC3B,cAAImB,CAAC,GAAGD,EAAE,CAACE,IAAH,CAAQb,KAAR,CAAR;;EACA,cAAIY,CAAJ,EAAO;EACL,gBAAI,CAACF,SAAL,EAAgB;EACdA,cAAAA,SAAS,GAAGE,CAAZ;EACD,aAFD,MAEO,IAAIF,SAAS,CAAC,CAAD,CAAT,CAAaI,MAAb,GAAsBF,CAAC,CAAC,CAAD,CAAD,CAAKE,MAA/B,EAAuC;EAC5CJ,cAAAA,SAAS,GAAGE,CAAZ;EACD;EACF;EACF,SApByB;EAsB1B;EAEA;;;EACAJ,QAAAA,SAAS,GAAIC,WAAW,CAAC,CAAD,CAAX,CAAeK,MAAf,GAAwBJ,SAAS,CAAC,CAAD,CAAT,CAAaI,MAAlD;EACD;;EAED,UAAIb,QAAQ,IAAI,IAAZ,IAAoBA,QAAQ,KAAKO,SAArC,EAAgD;EAC9C,aAAKb,QAAL,CAAc;EAAEC,UAAAA,KAAK,EAAE,QAAT;EAAmBI,UAAAA,KAAnB;EAA0BC,UAAAA,QAA1B;EAAoCE,UAAAA,QAApC;EAA8CC,UAAAA,UAA9C;EAA0DK,UAAAA,WAA1D;EAAuEH,UAAAA,MAAvE;EAA+EC,UAAAA,QAA/E;EAAyFG,UAAAA,SAAzF;EAAoGK,UAAAA,OAAO,EAAE,mBAA7G;EAAkIP,UAAAA;EAAlI,SAAd;EACD;;EACD,aAAOA,SAAP;EACD,KA/HI;EAgIL;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAS,IAAAA,QAAQ,EAAE,UAAUjB,KAAV,EAAiBC,QAAjB,EAA2B;EACnC,UAAID,KAAK,CAAC,CAAD,CAAL,KAAa,GAAjB,EAAsBA,KAAK,GAAGA,KAAK,CAACE,KAAN,CAAY,CAAZ,CAAR;EACtBF,MAAAA,KAAK,GAAG,MAAMA,KAAd;EAEA,UAAIG,QAAQ,GAAGT,SAAS,CAAC,CAAD,CAAxB;EACA,UAAIU,UAAU,GAAGD,QAAQ,CAACE,IAAT,CAAcL,KAAd,CAAjB;EACA,UAAIM,MAAM,GAAGb,SAAS,CAAC,CAAD,CAAtB;EACA,UAAIc,QAAQ,GAAGD,MAAM,CAACD,IAAP,CAAYL,KAAZ,CAAf,CAPmC;EASnC;;EACA,UAAIQ,SAAS,GAAIJ,UAAU,IAAIG,QAA/B;;EAEA,UAAIN,QAAQ,IAAI,IAAZ,IAAoBA,QAAQ,KAAKO,SAArC,EAAgD;EAC9C,aAAKb,QAAL,CAAc;EAAEC,UAAAA,KAAK,EAAE,UAAT;EAAqBI,UAAAA,KAArB;EAA4BC,UAAAA,QAA5B;EAAsCE,UAAAA,QAAtC;EAAgDC,UAAAA,UAAhD;EAA4DE,UAAAA,MAA5D;EAAoEC,UAAAA,QAApE;EAA8EQ,UAAAA,OAAO,EAAE,kBAAvF;EAA2GP,UAAAA;EAA3G,SAAd;EACD;;EACD,aAAOA,SAAP;EACD;EA7JI,GAAP;EA+JD;EAED;;;;;;;;;;;EAUO,SAAShB,KAAT,CAAeF,OAAf,EAAwB;EAC7B,SAAOA,OAAO,CAAC4B,KAAR,CAAc,IAAd,EACNC,GADM,CACF,UAAUC,IAAV,EAAgB;EACnBA,IAAAA,IAAI,GAAGA,IAAI,CAACC,IAAL,EAAP;EACA,WAAOD,IAAP;EACD,GAJM,EAKNE,MALM,CAKC,UAAUF,IAAV,EAAgB;EACtB,WAAOA,IAAI,IAAIA,IAAI,CAAC,CAAD,CAAJ,KAAY,GAA3B;EACD,GAPM,EAQNG,MARM,CAQC,UAAUC,KAAV,EAAiBJ,IAAjB,EAAuB;EAC7B,QAAIK,UAAU,GAAGL,IAAI,CAAC,CAAD,CAAJ,KAAY,GAA7B;;EACA,QAAIK,UAAJ,EAAgB;EACdL,MAAAA,IAAI,GAAGA,IAAI,CAAClB,KAAL,CAAW,CAAX,CAAP;EACD;;EACD,QAAIuB,UAAJ,EAAgB;EACdD,MAAAA,KAAK,CAAC,CAAD,CAAL,CAASE,IAAT,CAAcN,IAAd;EACD,KAFD,MAEO;EACLI,MAAAA,KAAK,CAAC,CAAD,CAAL,CAASE,IAAT,CAAcN,IAAd;EACD;;EACD,WAAOI,KAAP;EACD,GAnBM,EAmBJ,CAAE,EAAF,EAAM,EAAN,CAnBI,EAoBNL,GApBM,CAoBF,UAAUQ,IAAV,EAAgB;EACnBA,IAAAA,IAAI,GAAIA,IAAI,CACXC,IADO,GAEPT,GAFO,CAEHU,mBAFG,CAAR,CADmB;EAMnB;;EACA,QAAIF,IAAI,CAACb,MAAL,GAAc,CAAlB,EAAqB;EACnB,aAAO,CAAE,IAAIgB,MAAJ,CAAW,QAAQH,IAAI,CAACI,IAAL,CAAU,OAAV,CAAR,GAA6B,GAAxC,CAAF,EAAgDJ,IAAI,CAACR,GAAL,CAAUR,EAAD,IAAQ,IAAImB,MAAJ,CAAWnB,EAAX,CAAjB,CAAhD,CAAP;EACD,KATkB;;;EAWnB,WAAO,CAAE,IAAImB,MAAJ,CAAW,IAAX,CAAF,EAAoB,EAApB,CAAP;EACD,GAhCM,CAAP;EAiCD;;EAED,SAASD,mBAAT,CAA6BG,OAA7B,EAAsC;EACpC;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAIhC,KAAK,GAAGgC,OAAZ;EACA,MAAIrB,EAAE,GAAG,EAAT;EACA,MAAIsB,MAAM,GAAG,KAAb;EACA,MAAIC,SAAS,GAAG,KAAhB;;EACA,MAAIF,OAAO,CAAC,CAAD,CAAP,KAAe,GAAnB,EAAwB;EACtBC,IAAAA,MAAM,GAAG,IAAT;EACAD,IAAAA,OAAO,GAAGA,OAAO,CAAC9B,KAAR,CAAc,CAAd,CAAV;EACD;;EACD,MAAI8B,OAAO,CAACA,OAAO,CAAClB,MAAR,GAAiB,CAAlB,CAAP,KAAgC,GAApC,EAAyC;EACvCoB,IAAAA,SAAS,GAAG,IAAZ;EACAF,IAAAA,OAAO,GAAGA,OAAO,CAAC9B,KAAR,CAAc,CAAd,EAAiB8B,OAAO,CAAClB,MAAR,GAAiB,CAAlC,CAAV;EACD,GA3BmC;;;EA6BpC,QAAMqB,OAAO,GAAG,mDAAhB,CA7BoC;EA+BpC;;EACA,MAAIC,KAAJ;;EAEA,SAAO,CAACA,KAAK,GAAGD,OAAO,CAACtB,IAAR,CAAamB,OAAb,CAAT,MAAoC,IAA3C,EAAiD;EAC/C,QAAII,KAAK,CAAC,CAAD,CAAL,CAASC,QAAT,CAAkB,GAAlB,CAAJ,EAA4B;EAC1BJ,MAAAA,MAAM,GAAG,IAAT,CAD0B;EAG1B;EACA;EACA;EACA;EACA;EACD;;EACDtB,IAAAA,EAAE,IAAI2B,kBAAkB,CAACF,KAAK,CAAC,CAAD,CAAN,CAAxB;EACAzB,IAAAA,EAAE,IAAI,MAAMyB,KAAK,CAAC,CAAD,CAAX,GAAiB,GAAvB;EAEAJ,IAAAA,OAAO,GAAGA,OAAO,CAAC9B,KAAR,CAAckC,KAAK,CAAC,CAAD,CAAL,CAAStB,MAAvB,CAAV;EACD;;EACD,MAAIkB,OAAJ,EAAa;EACX,QAAIA,OAAO,CAACK,QAAR,CAAiB,GAAjB,CAAJ,EAA2B;EACzBJ,MAAAA,MAAM,GAAG,IAAT,CADyB;EAGzB;EACA;EACA;EACA;EACA;EACD;;EACDtB,IAAAA,EAAE,IAAI2B,kBAAkB,CAACN,OAAD,CAAxB;EACD,GA5DmC;;;EA+DpC,MAAIC,MAAJ,EAAY;EACVtB,IAAAA,EAAE,GAAG,SAASA,EAAd;EACD,GAFD,MAEO;EACLA,IAAAA,EAAE,GAAG,QAAQA,EAAb;EACD,GAnEmC;EAqEpC;EACA;EACA;EACA;;;EACA,MAAIuB,SAAJ,EAAe;EACb;EACAvB,IAAAA,EAAE,IAAI,KAAN;EACD,GAHD,MAGO;EACL;EACAA,IAAAA,EAAE,IAAI,WAAN;EACD,GA/EmC;EAkFpC;;;EACA,EAAW;EACT,QAAI;EACJ;EACE,UAAImB,MAAJ,CAAW,QAAQnB,EAAR,GAAa,GAAxB;EACD,KAHD,CAGE,OAAO4B,EAAP,EAAW;EACX1C,MAAAA,OAAO,CAACC,GAAR,CAAY,eAAZ,EAA6B;EAAEE,QAAAA,KAAF;EAASW,QAAAA,EAAT;EAAa4B,QAAAA;EAAb,OAA7B;EACD;EACF;;EACD,SAAO5B,EAAP;;EAEA,WAAS2B,kBAAT,CAA4B3B,EAA5B,EAAgC;EAC9B,WAAOA,EAAE;EAEP;EAFO,KAGN6B,OAHI,CAGI,QAHJ,EAGc,IAHd;EAAA,KAKJA,OALI,CAKI,+BALJ,EAKqC,MALrC,EAMJA,OANI,CAMI,KANJ,EAMW,MANX,EAOJA,OAPI,CAOI,WAPJ,EAOiB,gBAPjB,EAQJA,OARI,CAQI,UARJ,EAQgB,cARhB,EASJA,OATI,CASI,UATJ,EASgB,MAAM;EACzBN,MAAAA,SAAS,GAAG,IAAZ,CADyB;;EAEzB,aAAO,cAAP,CAFyB;EAG1B,KAZI,EAaJM,OAbI,CAaI,OAbJ,EAaa,IAbb;EAeL;EAfK,KAgBJA,OAhBI,CAgBI,aAhBJ,EAgBmB,UAhBnB,EAiBJA,OAjBI,CAiBI,KAjBJ,EAiBW,OAjBX,EAkBJA,OAlBI,CAkBI,KAlBJ,EAkBW,KAlBX,CAAP;EAmBD;EACF;;;;;;;;;"}