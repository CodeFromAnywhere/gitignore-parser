{"version":3,"file":"gitignoreParser.js","sources":["../lib/index.js"],"sourcesContent":["\n// force to false and smart code compressors can remove the resulting 'dead code':\nconst DEBUG = false;\n\n/**\n * Compile the given `.gitignore` content (not filename!)\n * and return an object with `accepts`, `denies` and `inspects` methods.\n * These methods each accepts a single filename or path and determines whether\n * they are acceptable or unacceptable according to the `.gitignore` definition.\n *\n * @param  {String} content The `.gitignore` content to compile.\n * @return {Object}         The helper object with methods that operate on the compiled content.\n */\nexport function compile(content) {\n  let parsed = parse(content),\n      positives = parsed[0],\n      negatives = parsed[1];\n\n  return {\n    /// Helper (which can be overridden by userland code) invoked when\n    /// any `accepts()`, `denies()` or `inspects()` fail to help\n    /// the developer analyze what is going on inside: some gitignore spec\n    /// bits are non-intuitive / non-trivial, after all.\n    diagnose: function (query) {\n      if (DEBUG) {\n        console.log(`${query.query}:`, query);\n      }\n    },\n    /// Return TRUE when the given `input` path PASSES the gitignore filters,\n    /// i.e. when the given input path is DENIED.\n    ///\n    /// Notes:\n    /// - you MUST postfix a input directory with '/' to ensure the gitignore\n    ///   rules can be applied conform spec.\n    /// - you MAY prefix a input directory with '/' when that directory is\n    ///   'rooted' in the same directory as the compiled .gitignore spec file.\n    accepts: function (input, expected) {\n      if (input[0] === '/') input = input.slice(1);\n      input = '/' + input;\n\n      let acceptRe = negatives;\n      let acceptTest = acceptRe.test(input);\n      let denyRe = positives;\n      let denyTest = denyRe.test(input);\n      let returnVal = (acceptTest || !denyTest);\n\n      if (expected != null && expected !== returnVal) {\n        this.diagnose({ query: 'accepts', input, expected, acceptRe, acceptTest, denyRe, denyTest, combine: '(Accept || !Deny)', returnVal });\n      }\n      return returnVal;\n    },\n    /// Return TRUE when the given `input` path FAILS the gitignore filters,\n    /// i.e. when the given input path is ACCEPTED.\n    ///\n    /// Notes:\n    /// - you MUST postfix a input directory with '/' to ensure the gitignore\n    ///   rules can be applied conform spec.\n    /// - you MAY prefix a input directory with '/' when that directory is\n    ///   'rooted' in the same directory as the compiled .gitignore spec file.\n    denies: function (input, expected) {\n      if (input[0] === '/') input = input.slice(1);\n      input = '/' + input;\n\n      let acceptRe = negatives;\n      let acceptTest = acceptRe.test(input);\n      let denyRe = positives;\n      let denyTest = denyRe.test(input);\n      // boolean logic:\n      //\n      // denies = !accepts =>\n      // = !(Accept || !Deny) =>\n      // = (!Accept && !!Deny) =>\n      // = (!Accept && Deny)\n      let returnVal = (!acceptTest && denyTest);\n\n      if (expected != null && expected !== returnVal) {\n        this.diagnose({ query: 'denies', input, expected, acceptRe, acceptTest, denyRe, denyTest, combine: '(!Accept && Deny)', returnVal });\n      }\n      return returnVal;\n    },\n    /// Return TRUE when the given `input` path is inspected by any .gitignore\n    /// filter line.\n    ///\n    /// You can use this method to help construct the decision path when you\n    /// process nested .gitignore files: .gitignore filters in subdirectories\n    /// MAY override parent .gitignore filters only when there's actually ANY\n    /// filter in the child .gitignore after all.\n    ///\n    /// Notes:\n    /// - you MUST postfix a input directory with '/' to ensure the gitignore\n    ///   rules can be applied conform spec.\n    /// - you MAY prefix a input directory with '/' when that directory is\n    ///   'rooted' in the same directory as the compiled .gitignore spec file.\n    inspects: function (input, expected) {\n      if (input[0] === '/') input = input.slice(1);\n      input = '/' + input;\n\n      let acceptRe = negatives;\n      let acceptTest = acceptRe.test(input);\n      let denyRe = positives;\n      let denyTest = denyRe.test(input);\n      // when any filter 'touches' the input path, it must match,\n      // no matter whether it's a deny or accept filter line:\n      let returnVal = (acceptTest || denyTest);\n\n      if (expected != null && expected !== returnVal) {\n        this.diagnose({ query: 'inspects', input, expected, acceptRe, acceptTest, denyRe, denyTest, combine: '(Accept || Deny)', returnVal });\n      }\n      return returnVal;\n    }\n  };\n}\n\n/**\n * Parse the given `.gitignore` content and return an array\n * containing positives and negatives.\n * Each of these in turn contains a regexp which will be\n * applied to the 'rooted' paths to test for *deny* or *accept*\n * respectively.\n *\n * @param  {String} content  The content to parse,\n * @return {Array[]}         The parsed positive and negatives definitions.\n */\nexport function parse(content) {\n  return content.split('\\n')\n  .map(function (line) {\n    line = line.trim();\n    return line;\n  })\n  .filter(function (line) {\n    return line && line[0] !== '#';\n  })\n  .reduce(function (lists, line) {\n    let isNegative = line[0] === '!';\n    if (isNegative) {\n      line = line.slice(1);\n    }\n    if (isNegative) {\n      lists[1].push(line);\n    } else {\n      lists[0].push(line);\n    }\n    return lists;\n  }, [ [], [] ])\n  .map(function (list) {\n    list =  list\n    .sort()\n    .map(prepareRegexPattern);\n\n    // don't need submatches, hence we use should use non-capturing `(?:...)` grouping regexes:\n    // those are generally faster than their submatch-capturing brothers:\n    if (list.length > 0) {\n      return new RegExp('(?:' + list.join(')|(?:') + ')');\n    }\n    // this regex *won't match a thing*:\n    return new RegExp('$^');\n\n  });\n}\n\nfunction prepareRegexPattern(pattern) {\n  // https://git-scm.com/docs/gitignore#_pattern_format\n  //\n  // * ...\n  //\n  // * If there is a separator at the beginning or middle (or both) of the pattern,\n  //   then the pattern is relative to the directory level of the particular\n  //   .gitignore file itself.\n  //   Otherwise the pattern may also match at any level below the .gitignore level.\n  //\n  // * ...\n  //\n  // * For example, a pattern `doc/frotz/` matches `doc/frotz` directory, but\n  //   not `a/doc/frotz` directory; however `frotz/` matches `frotz` and `a/frotz`\n  //   that is a directory (all paths are relative from the .gitignore file).\n  //\n  let input = pattern;\n  let re = '';\n  let rooted = false;\n  let directory = false;\n  if (pattern[0] === '/') {\n    rooted = true;\n    pattern = pattern.slice(1);\n  }\n  if (pattern[pattern.length - 1] === '/') {\n    directory = true;\n    pattern = pattern.slice(0, pattern.length - 1);\n  }\n  // keep character ranges intact:\n  const rangeRe = /^((?:[^\\[\\\\]|(?:\\\\.))*)\\[((?:[^\\]\\\\]|(?:\\\\.))*)\\]/;\n  // ^ could have used the 'y' sticky flag, but there's some trouble with infine loops inside\n  //   the matcher below then...\n  let match;\n\n  while ((match = rangeRe.exec(pattern)) !== null) {\n    if (match[1].includes('/')) {\n      rooted = true;\n      // ^ cf. man page:\n      //\n      //   If there is a separator at the beginning or middle (or both)\n      //   of the pattern, then the pattern is relative to the directory\n      //   level of the particular .gitignore file itself. Otherwise\n      //   the pattern may also match at any level below the .gitignore level.\n    }\n    re += transpileRegexPart(match[1]);\n    re += '[' + match[2] + ']';\n\n    pattern = pattern.slice(match[0].length);\n  }\n  if (pattern) {\n    if (pattern.includes('/')) {\n      rooted = true;\n      // ^ cf. man page:\n      //\n      //   If there is a separator at the beginning or middle (or both)\n      //   of the pattern, then the pattern is relative to the directory\n      //   level of the particular .gitignore file itself. Otherwise\n      //   the pattern may also match at any level below the .gitignore level.\n    }\n    re += transpileRegexPart(pattern);\n  }\n\n  // prep regexes assuming we'll always prefix the check string with a '/':\n  if (rooted) {\n    re = '^\\\\/' + re;\n  } else {\n    re = '\\\\/' + re;\n  }\n  // cf spec:\n  //\n  //   If there is a separator at the end of the pattern then the pattern\n  //   will only match directories, otherwise the pattern can match\n  //   **both files and directories**.                   (emphasis mine)\n  if (directory) {\n    re += '\\\\/$';\n  } else {\n    re += '\\\\/?$';\n  }\n\n  // regex validation diagnostics: better to check if the part is valid\n  // then to discover it's gone haywire in the big conglomerate at the end.\n  if (DEBUG) {\n    try {\n    /* eslint no-new:1 */\n      new RegExp('(?:' + re + ')');\n    } catch (ex) {\n      console.log('failed regex:', { input, re, ex });\n    }\n  }\n  return re;\n}\n\nfunction transpileRegexPart(re) {\n  return re\n      // unescape for these will be escaped again in the subsequent `.replace(...)`,\n      // whether they were escaped before or not:\n      .replace(/\\\\(.)/g, '$1')\n      // escape special regex characters:\n      .replace(/[\\-\\[\\]\\{\\}\\(\\)\\+\\.\\\\\\^\\$\\|]/g, '\\\\$&')\n      .replace(/\\?/g, '[^/]')\n      .replace(/\\/\\*\\*\\//g, '(?:/|(?:/.+/))')\n      .replace(/^\\*\\*\\//g, '(?:|(?:.+/))')\n      .replace(/\\/\\*\\*$/g, '(?:|(?:/.+))')    // `a/**` also accepts `a/` itself\n      .replace(/\\*\\*/g, '.*')\n      .replace(/\\*/g, '[^/]*')\n      .replace(/\\//g, '\\\\/');\n}\n"],"names":["compile","content","parsed","parse","positives","negatives","diagnose","query","accepts","input","expected","slice","acceptRe","acceptTest","test","denyRe","denyTest","returnVal","combine","denies","inspects","split","map","line","trim","filter","reduce","lists","isNegative","push","list","sort","prepareRegexPattern","length","RegExp","join","pattern","re","rooted","directory","rangeRe","match","exec","includes","transpileRegexPart","replace"],"mappings":"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"}